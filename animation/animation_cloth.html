<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <style>
        body {
            color: #eee;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;

            background-color: #000;
            margin: 0px;
            padding: 0px;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100%
        }
    </style>
</head>
<body>


<script src="../build/three.js"></script>
<script src="../resources/js/Cloth.js"></script>
<script>
    // Our Javascript will go here.
    // 测试， 进行模拟衣物
//    定义 pinsFormation 和 pins 变量， 用途未知。

    /*  */
    function togglePins() {

    }


    // 定义变量
    let camera, scene, renderer;

    let clothGeometry;

    let object;

    init();
    animate();

    function init() {

//        创建场景
        scene = new THREE.Scene();
        scene.background = new THREE.Color( 0xcce0ff );


//        创建相机
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 10000 );
        camera.position.set( 1000, 50, 1500 );


        // sphere

        let ballGeo = new THREE.SphereBufferGeometry( ballSize, 32, 16 );
        let ballMaterial = new THREE.MeshLambertMaterial();

        sphere = new THREE.Mesh( ballGeo, ballMaterial );
        sphere.castShadow = true;
        sphere.receiveShadow = true;
        scene.add( sphere );


        // 黑色是因为没有光照的原因。
//        添加光
        scene.add( new THREE.AmbientLight( 0x666666 ) );

        let light = new THREE.DirectionalLight( 0xdfebff, 1 );
        light.position.set( 50, 200, 100 );
        light.position.multiplyScalar( 1.3 );

        light.castShadow = true;

        light.shadow.mapSize.width = 1024;
        light.shadow.mapSize.height = 1024;

        let d = 300;

        light.shadow.camera.left = - d;
        light.shadow.camera.right = d;
        light.shadow.camera.top = d;
        light.shadow.camera.bottom = - d;

        light.shadow.camera.far = 1000;

        scene.add( light );

//        加载衣物 贴图， 并定义 衣物材质。
        let loader = new THREE.TextureLoader();
        let clothTexture = loader.load( '../resources/textures/patterns/circuit_pattern.png' );
//        设置各向异性
        clothTexture.anisotropy = 16;

        // 定义材质
        let clothMaterial = new THREE.MeshLambertMaterial( {

            map: clothTexture,
            side: THREE.doubleSided,
            alphaTest: 0.5

        } );


//        定义 衣物结构。这个参数实在是， 1.function, deal with uv mapping
        clothGeometry = new THREE.ParametricBufferGeometry( clothFunction, cloth.w, cloth.h );

//        定义 衣物几何体。这里的结构是使用 参数化 缓冲几何体。

        object = new THREE.Mesh( clothGeometry, clothMaterial );
        object.position.set( 0, 0, 0 );
        // 设置 阴影
        object.castShadow = true;
        scene.add( object );


//        定义 球体？

//        定义地面， 加载贴图。

//        添加多个 物体对象。


//        进行渲染。
        renderer = new THREE.WebGLRenderer();
        renderer.setSize( window.innerWidth, window.innerHeight );

        document.body.appendChild( renderer.domElement );


//        创建控制器。


        // test
//        let cube = new THREE.Mesh( new THREE.BoxGeometry( 100, 100, 100), new THREE.MeshBasicMaterial( { color: 0xff0000 } ) );
//        scene.add( cube );


    }

    function animate() {

        requestAnimationFrame( animate );

        let time = Date.now();
        // 添加 力的方向！ 最重要的代码。
        let windStrength = Math.cos( time / 7000 ) * 20 + 40;

        windForce.set( Math.sin( time / 2000 ), Math.cos( time / 300 ), Math.sin( time / 1000 ) );
        windForce.normalize();
        windForce.multiplyScalar( windStrength );

        simulate( time );

        render();

    }

    function render() {


        // 进行计算。 这里是依靠着重力落下。
        let p = cloth.particles;

        for ( let i = 0, il = p.length; i < il; i ++ ) {

            let v = p[ i ].position;

            clothGeometry.attributes.position.setXYZ( i, v.x, v.y, v.z );

        }

        clothGeometry.attributes.position.needsUpdate = true;

        clothGeometry.computeVertexNormals();

        sphere.position.copy( ballPosition );
        // 渲染。

        camera.lookAt( scene.position );
        renderer.render( scene, camera );

    }
    

</script>
</body>
</html>